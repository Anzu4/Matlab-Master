% Tropical Storm
%
% This is a more narrow version of Hurricane designed to analyze data
% associated with the single vesicle release experiments being performed
% currently. The general work flow is as follows, import tiff; subtract
% dark current and convert to photons from ADUs; perform rolling ball
% subtraction step; present user with image representation and ask for cut
% out; send parts of the cut out region to be analyzed based on temporal
% proximity to anticipated stimulus. this will require a configuration file
% be saved in the folder being analyzed
% AJN 6/12/18 Ryan Lab
clearvars; close all; clc;

%% USER VARIABLES
molish = 1; % expected number of molecules
q = 0.133;  % um/ pixel must be measured for experimental setup
pixw = 7;  % Window for cutting out region
fps = 3;    % frames per set is the number of frames / tiff stack
%% END USER INVOLVEMENT
[fname, fpath] = uigetfile('*local*');  % so far all localization experiments have been named with local in file name
cd(fpath);
% c = scrub_config(); % get imaging information.
% pix2pho = em_gain(c.Gain);
pix2pho = em_gain(300);
try % attempt to load dark current info
    load('back_subtract.mat')
catch lsterr
    mi1 = 0;
end
wind = -pixw:pixw; % array variable for selecting square region for fitting

%% Image Loading
i1 = [];
files = dir('*tif');
for i = 1:numel(files)
    try
    ind(i) = str2num(files(i).name(7:end-4));
    catch
        ind(i) = 0;
    end
end
[B,I] = sort(ind);

for i = 1:numel(files)
i1 = cat(3,i1,(readtiff(files(I(i)).name))/pix2pho); % load image, subtract dark current and convert to photons
end
% [B,I] = sort(ind); % determine numerical order of files
% [iprod,ip2] = rollingball(i1); % rolling ball background subtraction of all frames
ip1 = i1;
[m,n,o] = size(ip1); % grab size of images

clear i1
% This next section goes to each frame corresponding to a stimulus,
% averages the previous ave_fms number of frames and subtracts that from
% the subsequent imsafter frames. These background subtracted frames are
% then concatenated into a single variable dip1 and the corresponding
% framenumbers are saved in the fms variable
mins = (0.61*0.51/1.3)/(2*q);
maxs = 2*mins;

% sigma = 1.2;
% iprod = rollingball(ip1);
dip1(:,:,1) = ip1(:,:,2) - imgaussfilt(ip1(:,:,1),mins);
dip1(:,:,2) = ip1(:,:,3) - imgaussfilt(ip1(:,:,1),mins);
% dsi1(:,:,1) = movsum(ip1(:,:,2),3) - movsum(ip1(:,:,1),3);
% dsi1(:,:,2) = movsum(ip1(:,:,3),3) - movsum(ip1(:,:,1),3);
fms = [];
dps = zeros(m,n,2*(o)/3);
    
for i = 1:(o-fps)/3 % loop over stimuli
tic
    ind = i*3+2; % index now equals stimulus frame
    dip1 = cat(3,dip1, ip1(:,:,ind) - imgaussfilt(ip1(:,:,ind-1),mins));   % grab stim1 frame
    dip1 = cat(3,dip1, ip1(:,:,ind+1) - imgaussfilt(ip1(:,:,ind-1),mins)); % grab stim2 frame
%     dip1 = cat(3,dip1, imgaussfilt(ip1(:,:,ind),mins) - imgaussfilt(ip1(:,:,ind-1),mins));   % grab stim1 frame
%     dip1 = cat(3,dip1, imgaussfilt(ip1(:,:,ind+1),mins) - imgaussfilt(ip1(:,:,ind-1),mins)); % grab stim2 frame
%     dsi1 = cat(3,dsi1, movsum(ip1(:,:,ind),3) - movsum(ip1(:,:,ind-1),3));
% 	dsi1 = cat(3,dsi1, movsum(ip1(:,:,ind+1),3) - movsum(ip1(:,:,ind-1),3));
    fms =[fms,ind,ind+1];
    
%     [cents] = eyeindsky(ip1(:,:,ind-1:ind),molish);
%     for j = 1:molish
%     dps(cents(j,2),cents(j,1),numel(dip1(1,1,:))-1) = 1;
%     end
%     [cents] = eyeindsky(ip1(:,:,[ind-1,ind+1]),molish);
%     for j = 1:molish
%     dps(cents(j,2),cents(j,1),numel(dip1(1,1,:))) = 1;
%     end
%     t(i) = toc;
%     ajn_wait(t, i, (o-fps)/3);
end
rip1 = rollingball(dip1); % rolling ball the raw images
dip3 = bandpass(dip1,mins,maxs);
%% remove negative values
[m2,n2,o2] = size(dip1);
% for i = 1:o2
%     dip1(:,:,i) = dip1(:,:,i) - min(min(dip1(:,:,i)));
% end
dip1 = (dip1 > 0).*dip1;
% dip2 = lp_filt(dip1,4);
dip2 = bandpass(dip1,0.8,5.5);
surf(max(dip2,[],3));
thrsh = input('What is the threshold?');
% thrsh = max(max(max(dip2(:,:,1:2))));
dps = get_das_peaks(dip2,thrsh);

for i = 1:o2
    dig(:,:,i) = imgaussfilt(dip1(:,:,i),1.5);
    imagesc(dip2(:,:,i));
%     drawnow
    colormap('gray');
    hold on
    [row,col] = find(dps(:,:,i) == 1);
    plot(col,row,'rx');
    
    axis image
    drawnow;
    hold off
%     waitforbuttonpress
end

[sdi1, fnum, cents] = divide_up(rip1,pixw, dps);

%% Comment section to hold code
% imgaussfilt(dip1,1.5)
%

% [~,~,o] = size(dip1);
% imagesc(sum(dip1,3))
% title('Select an ROI');
% while true 
% [x,y] = ginput(1);
% x = round(x);
% y = round(y);
% draw_boxes([x,y],pixw);
% b = waitforbuttonpress;
% if b == 1
%     break
% end
% hold off
% imagesc(sum(dip1,3));
% end
% wind = -pixw:pixw;
% sdi1 = dip1(y+wind,x+wind,:);
% si1 = ip1(y+wind,x+wind,:);
% rat = [];
% for i = 1:(o-fps)/3
%     ind = i*3+1;
%     rat(numel(rat)+1) = rat_view(si1(:,:,ind:ind+1));
%     rat(numel(rat)+1) = rat_view(si1(:,:,[ind,ind+2]));
% end
% fnum = 1:numel(sdi1(1,1,:));
cal = load('C:\Users\AJN Lab\Documents\GitHub\Matlab-Master\Single-release-codes\bead_astig_3dcal.mat');
% cents = zeros(numel(sdi1(1,1,:)),2);
% [xf_all,xf_crlb, yf_all,yf_crlb,zf_all, zf_crlb, N, N_crlb,off_all, off_crlb, framenum_all, llv, iters] = da_splines(sdi1, fnum, cents, cal, pixw);
xf = [];
yf = [];
N = [];
sx = [];
sy = [];
O = [];
xfc = [];
yfx = [];
Oc =[];
Nc = [];
sxc = [];
syc = [];
yfc = [];
lv = [];
ang = 0.1047;
for i = 1:numel(fnum)
   [fits,crlb,llv] = func_mle_crlb(sdi1(:,:,i),0,0,3,ang); 
    x = fits(1)
    xf = [xf;x+cents(i,1)];
    yf = [yf;y+cents(i,2)];
    N = [N;fits(3)];
    O = [O;fits(6)];
    sx = [sx;fits(4)];
    sy = [sy;fits(5)];
    xfc = [xfc;crlb(1)];
    yfc = [yfc;crlb(2)];
    Nc = [Nc;crlb(3)];
    Oc = [Oc;crlb(6)];
    sxc = [sxc;crlb(4)];
    syc = [syc;crlb(5)];
    lv(i,1) = -abs(llv);
end
% lv = lv.';
ind = N > 0 & N < 1000;
ind = ind & lv./N > -1;
ind = ind & sx*2 > 1.5 & sx *2 < 6;
ind = ind & sy*2 > 1.5 & sy *2 < 6;


% zf_all = zf_all/q;
% zf_crlb = zf_crlb./q^2;
% [~,~,o] = size(sdi1);
% fluor = reshape(sum(sum(sdi1)),o,1);
% ind = N < fluor;
% ind = ind & zf_all*q < 0.5 & zf_all > -0.5;
% ind = ind & q*xf_crlb.^0.5 < 1 & q*yf_crlb.^0.5 < 1;

figure
plot(fluor);
xlabel('Framenumber')
ylabel('Photons')
title('Sum of every frame');
figure
scatter3(xf_all*q, yf_all*q, zf_all*q,[],mod(framenum_all,2));
axis equal
zlim([-0.700, 0.4]); % limit of Z in um
xlabel('Position um')
ylabel('Position um');
zlabel('A. Position um')
title('"Localizations"')
figure
% imagesc(std(si1,1,3))
set_scale(std(sdi1,1,3),q,4);
colormap('jet')
hold on
plot(xf_all(ind),yf_all(ind),'k.')
axis image
title('Projection of localizations onto image');
save('Localization_file.mat','xf_all','xf_crlb', 'yf_all','yf_crlb','zf_all', 'zf_crlb', 'N', 'N_crlb','off_all', 'off_crlb', 'framenum_all', 'llv', 'iters');
Traj_show;